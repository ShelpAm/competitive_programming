#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include <functional>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <unordered_map>
#include <unordered_set>
#include <utility>

using namespace std;
#define int long long
#define uint unsigned long long
#define PII pair<int, int>
#define VI array<int, 2>
#define VII array<array<int, 2>, 2>
const int mod = 1e9 + 7;
int const INF = 2e18;

class Sieve {
  public:
    explicit Sieve(std::uint_least64_t upper_bound)
        : _upper_bound{upper_bound}, _min_factor(upper_bound + 1, 0)
    {
        _primes.reserve(_upper_bound / static_cast<std::uint_least64_t>(
                                           std::log(_upper_bound)));

        for (int i = 2; i != _upper_bound + 1; ++i) {
            if (_min_factor[i] == 0) {
                _primes.push_back(i);
                _min_factor[i] = i;
            }
            for (auto const p : _primes) {
                if (i * p > upper_bound || p > _min_factor[i]) {
                    break;
                }
                _min_factor[i * p] = p;
            }
        }
    }

    // Time complexity:
    //     if x <= upper_bound then O(log(x))
    //     else if x <= upper_bound ^ 2 then O(sqrt(x))
    //     else unsupported
    [[nodiscard]] std::map<std::uint_least64_t, std::uint_least64_t>
    factorize(std::uint_least64_t x) const
    {
        // O(log(x))
        if (x <= _upper_bound) {
            std::vector<std::pair<std::uint_least64_t, std::uint_least64_t>>
                res;
            while (x != 1) {
                auto fact = _min_factor[x];
                if (res.empty() || res.back().first != fact) {
                    res.emplace_back(fact, 0);
                }
                ++res.back().second; // Count once
                x /= fact;
            }
            return {res.begin(), res.end()};
        }

        // O(sqrt(x) * log2(64) * log2(64)) = 36 * sqrt(x)
        if (x <= _upper_bound * _upper_bound) {
            std::map<std::uint_least64_t, std::uint_least64_t> res;
            for (auto const p : _primes) {
                if (p > x) {
                    break;
                }
                while (x % p == 0) {
                    x /= p;
                    ++res[p];
                }
            }
            if (x >= _min_factor.size()) {
                ++res[x];
            }
            return res;
        }

        assert(false && "x is too big, even greater than upper_bound ^ 2");
    }

    [[nodiscard]] bool is_prime(std::uint_least64_t x) const
    {
        return _min_factor[x] == x;
    }

    [[nodiscard]] std::vector<std::uint_least64_t> const &primes() const
    {
        return _primes;
    }

  private:
    std::uint_least64_t _upper_bound;
    std::vector<std::uint_least64_t> _primes;
    std::vector<std::uint_least64_t> _min_factor;
};

void solve()
{
    int n;
    cin >> n;
    vector<int> w(n + 1), c(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> c[i];
    }
    Sieve P(1000000);
    vector<vector<PII>> f(500001, vector<PII>(2));
    int ans = 0;
    auto x = P.factorize(10);
    // for (auto [prime, _] : x) {
    //   cout << prime << '\n';
    // }
    // for (int i = 1; i <= n; i++) {
    //   auto p = P.factorize(w[i]);
    //   int maxn = 0;
    //   for (auto [prime, _] : p) {
    //     vector<PII> t = f[prime];
    //     if (t[0].second != 0 && t[0].second != c[i]) {
    //       maxn = max(maxn, t[0].first);
    //     } else if (t[1].second != 0 && t[1].second != c[i]) {
    //       maxn = max(maxn, t[1].first);
    //     }
    //   }
    //   maxn += 1;
    //   ans = max(ans, maxn);
    //   for (auto [prime, _] : p) {
    //     vector<PII> t = f[prime];
    //     if (t[0].second == c[i]) {
    //       t[0].first = max(t[0].first, maxn);
    //     } else if (t[1].second == c[i]) {
    //       t[1].first = max(t[1].first, maxn);
    //     } else {
    //       if (maxn > t[0].first) {
    //         t[1] = t[0];
    //         t[0] = {maxn, c[i]};
    //       } else if (maxn > t[1].first) {
    //         t[1] = {maxn, c[i]};
    //       }
    //     }
    //     f[prime] = t;
    //   }
    // }
    cout << ans << '\n';
}
#undef int
int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    // cin >> T;
    while (T--) {
        solve();
    }
}
